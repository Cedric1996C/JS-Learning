<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export3.dtd">
<en-export export-date="20170803T065027Z" application="Evernote" version="Evernote Mac 6.11.1 (455061)">
<note><title>函数</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">
<en-note><div>1. 函数的声明：</div><div>- 函数命令、<span style="orphans: 2; widows: 2;">函数赋值语句、</span><span style="orphans: 2; widows: 2;">Function构造</span></div><div><br/></div><div><span style="orphans: 2; widows: 2;">2. 第一等公民</span></div><div><br/></div><div><span style="orphans: 2; widows: 2;">3. 函数名提升：如果同时采用function命令和函数赋值表达式声明同一个函数，总是采用函数赋值语句</span></div><div><br/></div><div><span style="orphans: 2; widows: 2;">4. 不要在try、if语句中声明函数</span></div><div><br/></div><div><span style="orphans: 2; widows: 2;">5. 函数属性：name 、length参数个数、toString返回源码（可以变相返回多行字符串）</span></div><div><br/></div><div><span style="orphans: 2; widows: 2;">6.函数作用域：</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- JavaScript中存在两种函数作用域：全局作用域、函数作用域</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- 变量提升：和全局作用域一样，函数作用域内部也存在变量提升</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- 函数执行时的作用域，是定义时的作用域，而不是调用时所在的作用域；同样，函数体内部声明的函数，作用域绑定函数内部</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- 上述是闭包机制的语法基础</span></div><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">7.参数</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- 函数的length为定义是需要的参数的个数</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- 参数传入时，不可省略靠前的参数而保留靠后的参数，需要显式的传入undefined</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- 传递方式：如果函数内部修改的不是对象的某个属性，而是直接替换掉整个参数，就不会影响原来的值</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- </span><span style="orphans: 2; widows: 2; color: rgb(34, 34, 34); font-family: 'Helvetica Neue', Helvetica, Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none; font-size: 14px;">如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- 同名参数：取值以后面的为准，如果要取到前面的同名参数，可使用argument对象</span></div><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">arguments对象：包含函数运行时的所有参数，这个对象只有在函数运行时才生效</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- arguments的形式很像数组，但是是一个对象。对数组生效的方法不能使用于arguments</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- 解决方法是用apply方法把arguments对象传进去</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">- 转化方法：slice方法或一一传值</span></div><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;">8.eval命令</div><div style="orphans: 2; widows: 2;">- 将字符串当做代码使用</div><div style="orphans: 2; widows: 2;">- eval本身没有作用域，都在当前作用域内执行，可能会修改当前作用域的变量的值，造成安全问题</div><div style="orphans: 2; widows: 2;">- 严格模式中eval声明不会影响到外部作用域，但可以进行读写</div><div style="orphans: 2; widows: 2;">- eval处理的字符串不会得到JS引擎的优化</div><div style="orphans: 2; widows: 2;">- 若非eval（expression）这样使用，均为间接调用，则总是全局作用域</div><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;"><br/></div></en-note>
]]></content><created>20170802T082217Z</created><updated>20170803T061423Z</updated><note-attributes><latitude>31.98611567654745</latitude><longitude>118.7587389941679</longitude><altitude>61.51672744750977</altitude><author>18851280888@163.com</author><source>desktop.mac</source><reminder-order>0</reminder-order></note-attributes></note>
</en-export>
